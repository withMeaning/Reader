import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:read_with_meaning/public/features/experience/manage/sort/domain/ordered.dart';
import 'package:read_with_meaning/public/features/experience/manage/sources/domain/source_table.dart';
import 'package:read_with_meaning/shared/domain/all_types_definition.dart';
import 'package:read_with_meaning/shared/domain/experience.dart';
import 'package:read_with_meaning/shared/domain/types/_command.dart';
import 'package:read_with_meaning/shared/domain/types/_extract.dart';
import 'package:read_with_meaning/shared/domain/types/_setting.dart';
import 'package:read_with_meaning/shared/domain/types/note.dart';
import 'package:read_with_meaning/shared/domain/types/read.dart';
import 'package:read_with_meaning/shared/domain/types/write.dart';
import 'package:read_with_meaning/public/features/experience/data/database/tables.dart';

import 'connection/connection.dart' as impl;
// Manually generated by `drift_dev schema steps` - this file makes writing
// migrations easier. See this for details:
// https://drift.simonbinder.eu/docs/advanced-features/migrations/#step-by-step
// import 'schema_versions.dart';

part 'database.g.dart';

@DriftDatabase(tables: [
  MeaningTypes,
  ExperienceEntries,
  ReadExtras,
  WriteExtras,
  NoteExtras,
  ExtractExtras,
  SettingExtras,
  CommandExtras,
  Orders,
  Sources
], include: {
  'package:read_with_meaning/public/features/experience/manage/sort/data/order_sql.drift'
})
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(impl.connect());

  AppDatabase.forTesting(DatabaseConnection super.connection);

  @override
  int get schemaVersion => 1;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(beforeOpen: (details) async {
      // Make sure that foreign keys are enabled
      await customStatement('PRAGMA foreign_keys = ON');
      if (details.wasCreated) {
        // Create a bunch of default values so the app doesn't look too empty
        // on the first start.
/*         await batch((b) {
          initDB(b, meaningTypes);
        }); */
        // TODO refactor. Didn't work with batch
        MeaningTypesCompanion experienceType =
            MeaningTypesCompanion.insert(name: AllTypes.read.name);
        await into(meaningTypes).insert(experienceType);
        ExperienceEntriesCompanion experience =
            ExperienceEntriesCompanion.insert(
          id: "1",
          content: "Welcome to Read With Meaning",
          author: "The Team",
          createdAt: DateTime.now(),
          type: AllTypes.read.name,
        );
        await into(experienceEntries).insert(experience);
        ReadExtrasCompanion readExtra = ReadExtrasCompanion.insert(
          id: "1",
          mainContent: "Hi! Welcome to Read With Meaning.",
          source: "tutorial",
          link: "docs.withmeaning.io/get_started",
        );
        await into(readExtras).insert(readExtra);
        OrdersCompanion order = OrdersCompanion.insert(
          id: "1",
          orderIndex: 0,
        );
        await into(orders).insert(order);
      }
    });
  }

  Future<void> insertOrderToTop(String id) {
    return transaction(() async {
      await _insertOrderToTop();
      await into(orders).insert(Order(id: id, orderIndex: 0));
    });
  }

  static final StateProvider<AppDatabase> provider = StateProvider((ref) {
    // !! this is the main line, where the DB is exposed as a StateProvider from RiverPod
    final database = AppDatabase();
    ref.onDispose(database.close);

    return database;
  });

  Stream<List<MeaningType>> watchTypes() {
    return (select(meaningTypes).watch());
  }

  Stream<List<ReadExtra>> watchReads() {
    return (select(readExtras).watch());
  }

  Future<ReadExtra> fetchRead(String id) async {
    return (select(readExtras)..where((tbl) => tbl.id.equals(id))).getSingle();
  }
}
